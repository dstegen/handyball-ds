<!DOCTYPE Html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>HandyBall PWA-Demo</title>
    <base href="/">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="manifest" href="manifest.webmanifest">
    <meta name="theme-color" content="#1976d2">

    <link rel="apple-touch-icon" sizes="180x180" href="/lib/apple-icon-180x180.png">
  </head>

  <body style="margin: 0; padding: 0; width: 100%; height: 100%"></body>
    <button id="permButton" onclick="permission();">OrientationAccess ok?</button>


  <script>
  /*** WepApp PART ***/
  // Check that service workers are supported
  if ('serviceWorker' in navigator) {
    // Use the window load event to keep the page load performant
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('sw.js');
    });
  }
  </script>


  <script src="/lib/three.js"></script>
  <script src="/lib/physi.js"></script>
  <script>
    /*** 3D PART  ***/
    // Physics settings
    Physijs.scripts.ammo = '/lib/ammo.js';
    Physijs.scripts.worker = '/lib/physijs_worker.js';

    // The "scene" is where stuff in our game will happen:
    var scene = new Physijs.Scene();
    scene.setGravity(new THREE.Vector3( 0, -100, 0 ));
    var flat = {flatShading: true};
    var light = new THREE.AmbientLight('white', 0.2);
    scene.add(light);

    // The "camera" is what sees the stuff:
    var aspectRatio = window.innerWidth / window.innerHeight;
    var camera = new THREE.PerspectiveCamera(75, aspectRatio, 1, 10000);
    camera.position.z = 500;
    scene.add(camera);

    // The "renderer" draws what the camera sees onto the screen:
    var renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    camera.position.set(0, 100, 200);
    camera.lookAt(new THREE.Vector3(0, 0, 0));
    renderer.shadowMap.enabled = true;

    // ******** START CODING ON THE NEXT LINE ********

    var lights = addLights();
    var ball = addBall();
    var board = addBoard1();
    //var goal = addGoal();
    var counter = 0;

    function addLights() {
      var lights = new THREE.Object3D();
      var light1 = new THREE.PointLight('white', 0.4);
      light1.position.set(50, 50, 175);
      light1.castShadow = true;
      lights.add(light1);

      var light2 = new THREE.PointLight('white', 0.5);
      light2.position.set(-50, 50, 175);
      light2.castShadow = true;
      lights.add(light2);

      scene.add(lights);
      return lights;
    }

    function addBall() {
      var shape = new THREE.SphereGeometry(10, 25, 21);
      var cover = new THREE.MeshPhongMaterial({color: 'blue'});
      cover.specular.setRGB(0.6, 0.6, 0.6);

      var ball = new Physijs.SphereMesh(shape, cover);
      ball.castShadow = true
      ball.position.set(-33, 200, -65);
      scene.add(ball);
      return ball;
    }

    function addBoard1() {
      var cover = new THREE.MeshPhongMaterial({color: 'gold'});
      cover.specular.setRGB(0.9, 0.9, 0.9);

      var shape = new THREE.CubeGeometry(50, 2, 200)

      var beam1 = new Physijs.BoxMesh(shape, cover, 0);
      beam1.position.set(-37, 0, 0);
      beam1.receiveShadow = true;

      var beam2 = new Physijs.BoxMesh(shape, cover, 0);
      beam2.position.set(75, 0, 0)
      beam2.receiveShadow = true;
      beam1.add(beam2);

      shape = new THREE.CubeGeometry(200, 2, 50);
      var beam3 = new Physijs.BoxMesh(shape, cover, 0);
      beam3.position.set(40, 0, -40);
      beam3.receiveShadow = true;
      beam1.add(beam3);

      var beam4 = new Physijs.BoxMesh(shape, cover, 0);
      beam4.position.set(40, 0, 40);
      beam4.receiveShadow = true;
      beam1.add(beam4);

      beam1.rotation.set(0.1, 0, 0);
      beam1.name = 'beam1';
      scene.add(beam1);
      return beam1;
    }

    function addBoard2() {
      var cover = new THREE.MeshPhongMaterial({color: 'gold'});
      var cover2 = new THREE.MeshPhongMaterial({color: 'red'});
      cover.specular.setRGB(0.9, 0.9, 0.9);

      var shape = new THREE.CubeGeometry(50, 2, 300)

      var beam1a = new Physijs.BoxMesh(shape, cover, 0);
      beam1a.position.set(-37, 0, 0);
      beam1a.receiveShadow = true;

      shape = new THREE.CubeGeometry(200, 2, 100)
      var beam2 = new Physijs.BoxMesh(shape, cover, 0);
      beam2.position.set(75, 0, 0)
      beam2.receiveShadow = true;
      beam1a.add(beam2);

      shape = new THREE.CubeGeometry(200, 2, 50);
      var beam3 = new Physijs.BoxMesh(shape, cover, 0);
      beam3.position.set(40, 0, -100);
      beam3.receiveShadow = true;
      beam1a.add(beam3);

      var beam4 = new Physijs.BoxMesh(shape, cover, 0);
      beam4.position.set(40, 0, 100);
      beam4.receiveShadow = true;
      beam1a.add(beam4);

      shape = new THREE.CubeGeometry(50, 2, 300)
      var beam5 = new Physijs.BoxMesh(shape, cover, 0);
      beam5.position.set(80, 0, 50);
      beam5.receiveShadow = true;
      beam1a.add(beam5);

      beam1a.rotation.set(0.1, 0, 0);
      beam1a.name = 'beam1a';
      scene.add(beam1a);
      return beam1a;
    }

    function reset() {
      ball.__dirtyPosition = true;
      ball.dirtyRotation = true;
      ball.position.set(-33, 200, -65);
      ball.setLinearVelocity(new THREE.Vector3(0, 0, 0));
      ball.setAngularVelocity(new THREE.Vector3(0, 0, 0));
      if (counter === 0) {
        scene.remove(scene.getObjectByName('beam1'));
        board = addBoard2();
        counter = 1;
      } else {
        scene.remove(scene.getObjectByName('beam1a'));
        board = addBoard1();
        counter = 0;
      }
      board.__dirtyRotation = true;
      board.rotation.set(0.1, 0, 0);
    }

    // Animate motion in the game
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();

    // Run physics
    function gameStep() {
      if (ball.position.y < -250) reset(ball);
      scene.simulate();
      // Update physics 60 times a second so that motion is smooth
      setTimeout(gameStep, 1000/60);
    }
    gameStep();

    // Keyboard controlls

    document.addEventListener("keydown", sendKeyDown);

    function sendKeyDown(event){
      var code = event.code;
      if (code == 'ArrowLeft') left();
      if (code == 'ArrowRight') right();
      if (code == 'ArrowUp') up();
      if (code == 'ArrowDown') down();
    }

    function left() { tilt('z', 0.05); }
    function right() { tilt('z', -0.05); }
    function up() { tilt('x', -0.05); }
    function down() {tilt('x', 0.05); }

    function tilt(dir, amount) {
      board.__dirtyRotation = true
      board.rotation[dir] = board.rotation[dir] + amount;
    }

  </script>


  <script>
    /*** DeviceOrientation PART ***/
    function permission () {
      if ( typeof( DeviceMotionEvent ) !== "undefined" && typeof( DeviceMotionEvent.requestPermission ) === "function" ) {
          // (optional) Do something before API request prompt.
          DeviceMotionEvent.requestPermission().then( response => {
              // (optional) Do something after API prompt dismissed.
              if ( response == "granted" ) {
                  document.getElementById('permButton').style.display ='none';
              }
          }).catch( console.error )
      } else {
          alert( "Sorry, DeviceMotionEvent is not defined!" );
      }
    }
    function handleOrientation(event) {
      var absolute = event.absolute;
      var alpha    = event.alpha;
      var beta     = event.beta;
      var gamma    = event.gamma;
      //alert(absolute);
      // Do stuff with the new orientation data
      if (window.orientation === 90) {
        // Landscape
        tilt('z', -beta/900);
        tilt('x', -gamma/900);
        //ball.position.x += beta;
        //ball.position.y += gamma;
      } else if (window.orientation === -90) {
        tilt('z', beta/900);
        tilt('x', gamma/900);
      } else if (window.orientation === 180) {
        tilt('z', gamma/900);
        tilt('x', -beta/900);
      } else {
      	// Portrait
        tilt('z', -gamma/900);
        tilt('x', beta/900);
        //ball.position.x += gamma;
        //ball.position.y -= beta;
      }
      //renderer.render(scene, camera);
    }
    window.addEventListener("deviceorientation", handleOrientation, true);
  </script>

</html>
